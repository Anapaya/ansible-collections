# coding: utf-8

"""
    Appliance Management API

    Management API for the Anapaya EDGE, CORE and GATE appliances

    The version of the OpenAPI document: v0.37.1
    Contact: ops@anapaya.net
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Optional
from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint, validator
from ansible.module_utils.appliance_api_client.models.config_scionas_neighbor_interface_bfd import ConfigSCIONASNeighborInterfaceBFD
from ansible.module_utils.appliance_api_client.models.config_scionas_neighbor_interface_remote import ConfigSCIONASNeighborInterfaceRemote

class ConfigSCIONASNeighborInterface(BaseModel):
    """
    SCION interface that links to the neighbor AS.  # noqa: E501
    """
    address: Optional[StrictStr] = Field(None, description="UDP/IP underlay endpoint of the SCION Interface. The data plane traffic is received on this address. The address must be specified as host:port. Both host and port must be specified.")
    administrative_state: Optional[StrictStr] = Field(None, description="Administrative state of the SCION interface.  Experimental: Currently only UP is supported.")
    bfd: Optional[ConfigSCIONASNeighborInterfaceBFD] = None
    description: Optional[StrictStr] = Field(None, description="Description, or comment, for the SCION interface.")
    enable_scion_rss: Optional[StrictBool] = Field(None, description="Flag to activate SCION RSS for this link. If activated, the router utilizes UDP source port entropy on the underlay such that the remote router can leverage RSS for SCION traffic. This can greatly improve throughput performance. Only enable it if the remote router supports SCION RSS.")
    interface_id: conint(strict=True, le=0, ge=1) = Field(..., description="SCION interface identifier. It must be unique in the SCION AS.")
    remote: Optional[ConfigSCIONASNeighborInterfaceRemote] = None
    scion_mtu: Optional[StrictInt] = Field(1472, description="The maximum transmission unit in bytes for SCION packets. This represents the protocol data unit (PDU) of the SCION layer on this interface and is usually calculated as maximum Ethernet payload - IP Header - UDP Header. ")
    __properties = ["address", "administrative_state", "bfd", "description", "enable_scion_rss", "interface_id", "remote", "scion_mtu"]

    @validator('administrative_state')
    def administrative_state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('UP', 'ADMIN_DOWN', 'DATAPLANE_ONLY'):
            raise ValueError("must be one of enum values ('UP', 'ADMIN_DOWN', 'DATAPLANE_ONLY')")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> ConfigSCIONASNeighborInterface:
        """Create an instance of ConfigSCIONASNeighborInterface from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of bfd
        if self.bfd:
            _dict['bfd'] = self.bfd.to_dict()
        # override the default output from pydantic by calling `to_dict()` of remote
        if self.remote:
            _dict['remote'] = self.remote.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> ConfigSCIONASNeighborInterface:
        """Create an instance of ConfigSCIONASNeighborInterface from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return ConfigSCIONASNeighborInterface.parse_obj(obj)

        _obj = ConfigSCIONASNeighborInterface.parse_obj({
            "address": obj.get("address"),
            "administrative_state": obj.get("administrative_state"),
            "bfd": ConfigSCIONASNeighborInterfaceBFD.from_dict(obj.get("bfd")) if obj.get("bfd") is not None else None,
            "description": obj.get("description"),
            "enable_scion_rss": obj.get("enable_scion_rss"),
            "interface_id": obj.get("interface_id"),
            "remote": ConfigSCIONASNeighborInterfaceRemote.from_dict(obj.get("remote")) if obj.get("remote") is not None else None,
            "scion_mtu": obj.get("scion_mtu") if obj.get("scion_mtu") is not None else 1472
        })
        return _obj


