# coding: utf-8

"""
    Appliance Management API

    Management API for the Anapaya EDGE, CORE and GATE appliances

    The version of the OpenAPI document: 0.1.0
    Contact: ops@anapaya.net
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
from pydantic import Field
from ansible.module_utils.appliance_api_client.models.config_bgp_neighbor_bfd import ConfigBgpNeighborBfd
from ansible.module_utils.appliance_api_client.models.config_bgp_neighbor_timers import ConfigBgpNeighborTimers
from ansible.module_utils.appliance_api_client.models.config_bgp_neighbor_transport import ConfigBgpNeighborTransport
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class ConfigBgpNeighbor(BaseModel):
    """
    List of BGP neighbors configured on the local system, uniquely identified by peer IPv4 or IPv6 address
    """ # noqa: E501
    auth_password: Optional[StrictStr] = Field(default=None, description="An MD5 authentication password for use with the neighboring device.")
    bfd: Optional[ConfigBgpNeighborBfd] = None
    description: Optional[StrictStr] = Field(default=None, description="An optional textual description of the neighbor.")
    ebgp_multihop: Optional[StrictInt] = Field(default=None, description="Specifying ebgp-multihop allows sessions with eBGP neighbors to establish when they are multiple hops away. When the neighbor is not directly connected and this setting is not enabled, the session will not establish.")
    enabled: Optional[StrictBool] = Field(default=True, description="Whether the BGP peer is enabled. In cases where the enabled leaf is set to false, the local system will not initiate connections to the neighbor, and will not respond to TCP connections attempts from the neighbor. If the BGP session is established at the time that this property is set to false, the session will be ceased.")
    local_as: Optional[StrictInt] = Field(default=None, description="The local BGP autonomous system number that is to be used when establishing sessions with the remote peer or peer group, if this differs from the global BGP router autonomous system number.")
    neighbor_address: Optional[StrictStr] = Field(default=None, description="Address of the BGP peer, either IPv4 or IPv6.")
    peer_as: Optional[StrictInt] = Field(default=None, description="BGP autonomous system number of the peer.")
    timers: Optional[ConfigBgpNeighborTimers] = None
    transport: Optional[ConfigBgpNeighborTransport] = None
    ttl_security: Optional[StrictInt] = Field(default=None, description="BGP Time To Live (TTL) security check. Reference: RFC 5082: The Generalized TTL Security Mechanism (GTSM), RFC 7454: BGP Operations and Security.")
    __properties: ClassVar[List[str]] = ["auth_password", "bfd", "description", "ebgp_multihop", "enabled", "local_as", "neighbor_address", "peer_as", "timers", "transport", "ttl_security"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of ConfigBgpNeighbor from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of bfd
        if self.bfd:
            _dict['bfd'] = self.bfd.to_dict()
        # override the default output from pydantic by calling `to_dict()` of timers
        if self.timers:
            _dict['timers'] = self.timers.to_dict()
        # override the default output from pydantic by calling `to_dict()` of transport
        if self.transport:
            _dict['transport'] = self.transport.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of ConfigBgpNeighbor from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "auth_password": obj.get("auth_password"),
            "bfd": ConfigBgpNeighborBfd.from_dict(obj.get("bfd")) if obj.get("bfd") is not None else None,
            "description": obj.get("description"),
            "ebgp_multihop": obj.get("ebgp_multihop"),
            "enabled": obj.get("enabled") if obj.get("enabled") is not None else True,
            "local_as": obj.get("local_as"),
            "neighbor_address": obj.get("neighbor_address"),
            "peer_as": obj.get("peer_as"),
            "timers": ConfigBgpNeighborTimers.from_dict(obj.get("timers")) if obj.get("timers") is not None else None,
            "transport": ConfigBgpNeighborTransport.from_dict(obj.get("transport")) if obj.get("transport") is not None else None,
            "ttl_security": obj.get("ttl_security")
        })
        return _obj


